<!DOCTYPE html><html class="default" lang="en" data-base="."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>@conterra/reactivity-core - v0.4.4</title><meta name="description" content="Documentation for @conterra/reactivity-core"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/icons.js" id="tsd-icons-script"></script><script async src="assets/search.js" id="tsd-search-script"></script><script async src="assets/navigation.js" id="tsd-nav-script"></script><script async src="assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">@conterra/reactivity-core - v0.4.4</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><h1>@conterra/reactivity-core - v0.4.4</h1></div><div class="tsd-panel tsd-typography"><a id="conterrareactivity-core" class="tsd-anchor"></a><h1 class="tsd-anchor-link">@conterra/reactivity-core<a href="#conterrareactivity-core" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h1><p>UI framework independent reactivity library with support for all kinds of values.</p>
<p>Click here to visit the <a href="https://conterra.github.io/reactivity/latest/">rendered API Documentation</a>.</p>
<a id="quick-example" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Quick Example<a href="#quick-example" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">computed</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">firstName</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">lastName</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;Doe&quot;</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">fullName</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-3">`</span><span class="hl-4">${</span><span class="hl-2">firstName</span><span class="hl-7">.</span><span class="hl-2">value</span><span class="hl-4">}</span><span class="hl-3"> </span><span class="hl-4">${</span><span class="hl-2">lastName</span><span class="hl-7">.</span><span class="hl-2">value</span><span class="hl-4">}</span><span class="hl-3">`</span><span class="hl-1">);</span><br/><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">fullName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">fullName</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">fullName</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    {</span><br/><span class="hl-1">        </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-2">firstName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;Jane&quot;</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<a id="usage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Usage<a href="#usage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Signals are reactive &quot;boxes&quot; that contain a value that may change at any time.
They can be easily watched for changes by, for example, registering a callback using <code>watch()</code>.</p>
<p>Signals may also be composed via <em>computed</em> signals, whose values are derived from other signals and are then automatically kept up to date.
They can also be used in classes (or plain objects) for organization based on concern or privacy.</p>
<a id="basics" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Basics<a href="#basics" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The following snippet creates a signal <code>r</code> through the function <code>reactive&lt;T&gt;()</code> that initially holds the value <code>&quot;foo&quot;</code>.
<code>reactive&lt;T&gt;()</code> is one of the most basic forms to construct a signal:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;foo&quot;</span><span class="hl-1">);</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">r</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// prints &quot;foo&quot;</span><br/><br/><span class="hl-2">r</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;bar&quot;</span><span class="hl-1">;</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">r</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// prints &quot;bar&quot;</span>
</code><button type="button">Copy</button></pre>

<p>The current value of a signal can be accessed by reading the property <code>.value</code>.
If you have a writable signal (which is the case for signals returned by <code>reactive&lt;T&gt;()</code>), you can update the inner value by assigning to the property <code>.value</code>.</p>
<p>Whenever the value of a signal changes, any watcher (a party interested in the current value) will automatically be notified.
The <code>effect()</code> function is one way to track one (or many) signals:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;foo&quot;</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// Effect callback is executed once; prints &quot;foo&quot; immediately</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// This access to `r.value` is tracked by the effect.</span><br/><span class="hl-1">    </span><span class="hl-8">// When the signal&#39;s value changes, the effect is executed again.</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">r</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// Triggers another execution of the effect; prints &quot;bar&quot; now.</span><br/><span class="hl-2">r</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;bar&quot;</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<p><code>effect(callback)</code> works like this:</p>
<ul>
<li>First, it will execute the given <code>callback</code> immediately.</li>
<li>During the execution, it tracks all signals whose values were accessed by <code>callback</code>.
This also works indirectly, for example if you call one or more functions which internally use signals.</li>
<li>When <em>any</em> of those signals are updated, the effect will re-execute <code>callback</code>.</li>
<li>These re-executions will happen indefinitely: either until the signals no longer change or until the effect has been destroyed.
Effects can be destroyed by using the object returned by <code>effect()</code> (see <a href="#cleanup">Cleanup</a>).</li>
<li>For an alternative API that doesn't trigger on <em>every</em> change, see <a href="#effect-vs-watch">watch()</a>.</li>
</ul>
<p>Signals can be composed by deriving values from them via <code>computed()</code>.
<code>computed()</code> takes a callback function as its argument.
That function can access any number of signals and should then return some JavaScript value.
The following example creates a computed signal that always returns twice the original <code>age</code>.</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">computed</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">age</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">21</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">doubleAge</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">age</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> * </span><span class="hl-9">2</span><span class="hl-1">);</span><br/><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">doubleAge</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// 42</span><br/><span class="hl-2">age</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">22</span><span class="hl-1">;</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">doubleAge</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// 44</span>
</code><button type="button">Copy</button></pre>

<p>Computed signals can be watched (e.g. via <code>effect()</code>) like any other signal:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">computed</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">age</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">21</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">doubleAge</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">age</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> * </span><span class="hl-9">2</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// prints 42</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">doubleAge</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// re-executes effect, which prints 44</span><br/><span class="hl-2">age</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">22</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<p>Computed signals only re-compute their value (by invoking the callback function) when any of their dependencies have changed.
For as long as nothing has changed, the current value will be cached.
This can make even complex computed signals very efficient.</p>
<p>Note that the callback function for a computed signal should be stateless:
it is supposed to compute a value (possibly very often), and it should not change the state of the application while doing so.</p>
<a id="using-signals-for-reactive-object-properties" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Using signals for reactive object properties<a href="#using-signals-for-reactive-object-properties" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>You can use signals in your classes (or single objects) to implement reactive objects.
For example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">class</span><span class="hl-1"> </span><span class="hl-10">Person</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// Could be private or public</span><br/><span class="hl-1">    </span><span class="hl-2">_name</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;&quot;</span><span class="hl-1">);</span><br/><br/><span class="hl-1">    </span><span class="hl-4">get</span><span class="hl-1"> </span><span class="hl-6">name</span><span class="hl-1">() {</span><br/><span class="hl-1">        </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-4">this</span><span class="hl-1">.</span><span class="hl-2">_name</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    }</span><br/><br/><span class="hl-1">    </span><span class="hl-4">set</span><span class="hl-1"> </span><span class="hl-6">name</span><span class="hl-1">(</span><span class="hl-2">value</span><span class="hl-1">) {</span><br/><span class="hl-1">        </span><span class="hl-8">// Reactive write -&gt; watches that used the `name` getter are notified.</span><br/><span class="hl-1">        </span><span class="hl-8">// We could use this setter (which could also be a normal method) to enforce preconditions.</span><br/><span class="hl-1">        </span><span class="hl-4">this</span><span class="hl-1">.</span><span class="hl-2">_name</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>Instances of person are now reactive, since their state is actually stored in signals:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Person class from previous example</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">p</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">Person</span><span class="hl-1">();</span><br/><span class="hl-2">p</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1"> = </span><span class="hl-3">&quot;E. Example&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Prints &quot;E. Example&quot;</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">p</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// Triggers effect again; prints &quot;T. Test&quot;</span><br/><span class="hl-2">p</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1"> = </span><span class="hl-3">&quot;T. Test&quot;</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<p>You can also provide computed values or accessor methods in your class:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">computed</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// In this example, first name and last name can only be written to.</span><br/><span class="hl-8">// Only the combined full name is available to users of the class.</span><br/><span class="hl-4">class</span><span class="hl-1"> </span><span class="hl-10">Person</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">_firstName</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-2">_lastName</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;Doe&quot;</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-2">_fullName</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-3">`</span><span class="hl-4">${</span><span class="hl-4">this</span><span class="hl-7">.</span><span class="hl-2">_firstName</span><span class="hl-7">.</span><span class="hl-2">value</span><span class="hl-4">}</span><span class="hl-3"> </span><span class="hl-4">${</span><span class="hl-4">this</span><span class="hl-7">.</span><span class="hl-2">_lastName</span><span class="hl-7">.</span><span class="hl-2">value</span><span class="hl-4">}</span><span class="hl-3">`</span><span class="hl-1">);</span><br/><br/><span class="hl-1">    </span><span class="hl-6">setFirstName</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">        </span><span class="hl-4">this</span><span class="hl-1">.</span><span class="hl-2">_firstName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">name</span><span class="hl-1">;</span><br/><span class="hl-1">    }</span><br/><br/><span class="hl-1">    </span><span class="hl-6">setLastName</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">        </span><span class="hl-4">this</span><span class="hl-1">.</span><span class="hl-2">_lastName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">name</span><span class="hl-1">;</span><br/><span class="hl-1">    }</span><br/><br/><span class="hl-1">    </span><span class="hl-6">getFullName</span><span class="hl-1">() {</span><br/><span class="hl-1">        </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-4">this</span><span class="hl-1">.</span><span class="hl-2">_fullName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<a id="effect-vs-watch" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Effect vs. Watch<a href="#effect-vs-watch" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>We provide two different APIs to run code when reactive values change.
The simpler one is effect <code>effect()</code>:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r2</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r3</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// Will run whenever _any_ of the given signals changed,</span><br/><span class="hl-8">// even if the sum turns out to be the same.</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">sum</span><span class="hl-1"> = </span><span class="hl-2">r1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> + </span><span class="hl-2">r2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> + </span><span class="hl-2">r3</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">sum</span><span class="hl-1">);</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>If your effect callbacks become more complex, it may be difficult to control which signals are ultimately used.
This can result in your effect running too often, because you're really only interested in <em>some</em> changes and not all of them.</p>
<p>In that case, you can use <code>watchValue()</code> (or one of the other <code>watch</code> variants) to have more fine grained control:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r2</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">r3</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span><br/><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-8">// (1)</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">sum</span><span class="hl-1"> = </span><span class="hl-2">r1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> + </span><span class="hl-2">r2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> + </span><span class="hl-2">r3</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">        </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-2">sum</span><span class="hl-1">;</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-8">// (2)</span><br/><span class="hl-1">    (</span><span class="hl-2">sum</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">sum</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-8">// (3)</span><br/><span class="hl-1">    { </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><span class="hl-1"> }</span><br/><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p><code>watchValue()</code> takes two functions and one (optional) options object:</p>
<ul>
<li><strong>(1)</strong>: The <em>selector</em> function.
This function's body is tracked (like in <code>effect()</code>) and all its reactive dependencies are recorded.
The function must return the value you want to watch and it should not have any side effects.</li>
<li><strong>(2)</strong>: The <em>callback</em> function.
This function is called whenever the selector function returned a different value, and it receives that value as its first argument.
The callback itself is <em>not</em> reactive and it may trigger arbitrary side effects.</li>
<li><strong>(3)</strong>: By default, the callback function will only be invoked after the watched value changed at least once.
By specifying <code>immediate: true</code>, the callback will also run for the initial value.</li>
</ul>
<p>In this example, the callback function will only re-run when the computed sum truly changed.</p>
<a id="accessing-previous-values" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Accessing previous values<a href="#accessing-previous-values" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The callback function of <code>watchValue()</code> can access the previous value via its second argument:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">counter</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">counter</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">count</span><span class="hl-1">, </span><span class="hl-2">oldCount</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">count</span><span class="hl-1">, </span><span class="hl-2">oldCount</span><span class="hl-1">);</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-2">counter</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-8">// Prints 1 0</span>
</code><button type="button">Copy</button></pre>

<p>Note that the second argument will be undefined for the first execution if <code>immediate: true</code> has been set (because there is no previous value).</p>
<a id="returning-cleanup-functions" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Returning cleanup functions<a href="#returning-cleanup-functions" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>You can return a function from <code>effect</code> and <code>watch</code> callbacks.
This function will be invoked before the effect or watch is triggered again, or if the effect / watch is being destroyed.</p>
<p>You can use this function to undo or cancel an action started by your callback.</p>
<p>The following example fetches the user details for a given user id whenever that id changes:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">userId</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;test-1&quot;</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// Fetch user details whenever the user id changes.</span><br/><span class="hl-8">// The cleanup function cancels the previous job if it&#39;s still running.</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">controller</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">AbortController</span><span class="hl-1">();</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">id</span><span class="hl-1"> = </span><span class="hl-2">userId</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-6">fetchUserDetails</span><span class="hl-1">(</span><span class="hl-2">id</span><span class="hl-1">, </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-2">signal</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-0">return</span><span class="hl-1"> () </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-6">abort</span><span class="hl-1">();</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// Same thing, using watchValue():</span><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">userId</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">id</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">controller</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">AbortController</span><span class="hl-1">();</span><br/><span class="hl-1">        </span><span class="hl-6">fetchUserDetails</span><span class="hl-1">(</span><span class="hl-2">id</span><span class="hl-1">, </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-2">signal</span><span class="hl-1">);</span><br/><span class="hl-1">        </span><span class="hl-0">return</span><span class="hl-1"> () </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">            </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-6">abort</span><span class="hl-1">();</span><br/><span class="hl-1">        };</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    { </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><span class="hl-1"> }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-8">// Trigger watch and effect</span><br/><span class="hl-2">userId</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;test-2&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">async</span><span class="hl-1"> </span><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">fetchUserDetails</span><span class="hl-1">(</span><span class="hl-2">id</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">, </span><span class="hl-2">signal</span><span class="hl-1">: </span><span class="hl-10">AbortSignal</span><span class="hl-1">): </span><span class="hl-10">Promise</span><span class="hl-1">&lt;</span><span class="hl-10">void</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">    </span><span class="hl-8">// ... would do a network request</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;fetch user&quot;</span><span class="hl-1">, </span><span class="hl-2">id</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<a id="cheat-sheet-variants-of-effect-and-watch" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Cheat sheet: variants of effect and watch<a href="#cheat-sheet-variants-of-effect-and-watch" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The following table provides a quick overview of the different variants of <code>effect</code> and <code>watch</code>:</p>
<blockquote>
<p>NOTE: In most circumstances, <code>watchValue</code>, <code>watch</code> or <code>effect</code> are the right choice.
The <code>sync*</code> variants are useful when you need to run the callback immediately.
For more details, see <a href="#sync-vs-async-effect--watch">Sync vs async effect / watch</a>.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Function</th>
<th>Kind of values</th>
<th>Callback condition</th>
<th>Callback delay</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>effect</code></td>
<td>N/A</td>
<td>After <em>any</em> used signal changes.</td>
<td>Slight delay.</td>
</tr>
<tr>
<td><code>watchValue</code></td>
<td>Single value.</td>
<td>After the watched value changed.</td>
<td>Slight delay.</td>
</tr>
<tr>
<td><code>watch</code></td>
<td>Multiple values (via array with shallow equality).</td>
<td>After one ore more of the watched values changed.</td>
<td>Slight delay.</td>
</tr>
<tr>
<td><code>syncEffect</code></td>
<td>N/A</td>
<td>After <em>any</em> used signal changed.</td>
<td>No delay.</td>
</tr>
<tr>
<td><code>syncWatchValue</code></td>
<td>Single value.</td>
<td>After the watched value changed.</td>
<td>No delay.</td>
</tr>
<tr>
<td><code>syncWatch</code></td>
<td>Multiple values (via array with shallow equality).</td>
<td>After one ore more of the watched values changed.</td>
<td>No delay.</td>
</tr>
</tbody>
</table>
<p>Note that <code>watchValue</code> and <code>watch</code> are almost the same.
<code>watch</code> supports watching multiple values at once directly (but forces you to return an array) while <code>watchValue</code> only supports a single value.
In truth, only their default <code>equal</code> functions are different: <code>watchValue</code> uses <code>===</code> while <code>watch</code> uses shallow array equality.</p>
<a id="complex-values" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Complex values<a href="#complex-values" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Up to this point, examples have used primitive values such as strings or integers.
Signals support <em>any</em> kind of <code>value</code>, for example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">currentUser</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">user</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">user</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    { </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><span class="hl-1"> }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-8">// Assignment to a signal&#39;s `.value` is reactive</span><br/><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 2&quot;</span><span class="hl-1"> };</span>
</code><button type="button">Copy</button></pre>

<p>You should keep in mind that, by default, change detection is based on JavaScript's default comparison (i.e. <code>===</code>).
This means that objects or arrays (or any other reference type) may trigger changes even if their contents are equivalent (equal <em>content</em> but different <em>identity</em>).
For example, the following change would trigger the <code>watch()</code> of the previous example, even though the <code>name</code> is the same:</p>
<pre><code class="ts"><span class="hl-8">// new object and thus a change</span><br/><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><span class="hl-1"> };</span>
</code><button type="button">Copy</button></pre>

<p>For this reason, <code>reactive</code> and <code>computed</code> allow you to supply a custom equality function.
This allows you to ignore certain updates by specifying that a value is <em>equal</em> to another value:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">currentUser</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><br/><span class="hl-1">    {</span><br/><span class="hl-1">        </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    {</span><br/><span class="hl-1">        </span><span class="hl-6">equal</span><span class="hl-2">:</span><span class="hl-1"> (</span><span class="hl-2">u1</span><span class="hl-1">, </span><span class="hl-2">u2</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">u1</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1"> === </span><span class="hl-2">u2</span><span class="hl-1">.</span><span class="hl-2">name</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">user</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">user</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    { </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><span class="hl-1"> }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-8">// Assignment is ignored because the name is the same.</span><br/><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><span class="hl-1"> };</span>
</code><button type="button">Copy</button></pre>

<p>When you only need custom equality rules for a single <code>watch</code>, you can also use its <code>equal</code> option directly:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// No custom equality here.</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">currentUser</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-2">user</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">user</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    {</span><br/><span class="hl-1">        </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><span class="hl-1">,</span><br/><span class="hl-1">        </span><span class="hl-8">// Custom equality directly for the watch callback.</span><br/><span class="hl-1">        </span><span class="hl-6">equal</span><span class="hl-2">:</span><span class="hl-1"> (</span><span class="hl-2">prev</span><span class="hl-1">, </span><span class="hl-2">next</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">            </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-2">prev</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1"> === </span><span class="hl-2">next</span><span class="hl-1">.</span><span class="hl-2">name</span><span class="hl-1">;</span><br/><span class="hl-1">        }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-8">// Assignment is ignored because the name is the same.</span><br/><span class="hl-2">currentUser</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">name:</span><span class="hl-1"> </span><span class="hl-3">&quot;User 1&quot;</span><span class="hl-1"> };</span>
</code><button type="button">Copy</button></pre>

<a id="working-with-collections" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Working with collections<a href="#working-with-collections" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>As mentioned above, signals support any kind of value.
This means that you can easily wrap an object, an array, or any other kind of container (e.g. Map/Set) in a signal.
However, you will only be notified when the <em>object</em> (or array) changes, and not when its <em>content</em> does.
In other words, deep reactivity is not support for &quot;normal&quot; JavaScript values.</p>
<p>At this point, we can recommend two approaches, based on your requirements.</p>
<a id="using-immutable-values" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Using immutable values<a href="#using-immutable-values" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>This approach can be convenient for small collections or collections that don't update very often.
Essentially, instead of updating the content of an collection, you replace the entire collection with an updated one:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">authors</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">&lt;</span><span class="hl-10">string</span><span class="hl-1">[]&gt;([</span><span class="hl-3">&quot;Tolkien&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Grisham&quot;</span><span class="hl-1">]);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">authors</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">addAuthor</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-8">// Replace the array instead of updating it in place.</span><br/><span class="hl-1">    </span><span class="hl-8">// This way, we can use a normal signal for reactivity.</span><br/><span class="hl-1">    </span><span class="hl-2">authors</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">authors</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">.</span><span class="hl-6">concat</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-6">addAuthor</span><span class="hl-1">(</span><span class="hl-3">&quot;King&quot;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="using-reactive-collection-classes" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Using reactive collection classes<a href="#using-reactive-collection-classes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>We implemented a few classes to make working with reactive collection easier, see <a href="#reactive-collections">Reactive Collections</a>.</p>
<p>The previous example could also be written as:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveArray</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// NOTE: not a normal array (but mostly API-compatible).</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">authors</span><span class="hl-1"> = </span><span class="hl-6">reactiveArray</span><span class="hl-1">([</span><span class="hl-3">&quot;Tolkien&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Grisham&quot;</span><span class="hl-1">]);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">authors</span><span class="hl-1">.</span><span class="hl-6">getItems</span><span class="hl-1">());</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">addAuthor</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-2">authors</span><span class="hl-1">.</span><span class="hl-6">push</span><span class="hl-1">(</span><span class="hl-2">name</span><span class="hl-1">);</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-6">addAuthor</span><span class="hl-1">(</span><span class="hl-3">&quot;King&quot;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="cleanup" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Cleanup<a href="#cleanup" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Both <code>effect()</code> and <code>watch()</code> return a <code>CleanupHandle</code> to stop watching for changes:</p>
<pre><code class="ts"><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">h1</span><span class="hl-1"> = </span><span class="hl-6">effect</span><span class="hl-1">(</span><span class="hl-8">/* ... */</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">h2</span><span class="hl-1"> = </span><span class="hl-6">watch</span><span class="hl-1">(</span><span class="hl-8">/* ... */</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// When you are no longer interested in changes:</span><br/><span class="hl-2">h1</span><span class="hl-1">.</span><span class="hl-6">destroy</span><span class="hl-1">();</span><br/><span class="hl-2">h2</span><span class="hl-1">.</span><span class="hl-6">destroy</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<p>When a watcher is not cleaned up properly, it will continue to execute (possibly forever).
This leads to unintended side effects, unnecessary memory consumption and waste of computational power.</p>
<a id="reactive-collections" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Reactive collections<a href="#reactive-collections" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This package provides a set of collection classes to simplify working with complex values.</p>
<a id="array" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Array<a href="#array" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The <code>ReactiveArray&lt;T&gt;</code> behaves largely like a normal <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array&lt;T&gt;</code></a>.
Most standard methods have been reimplemented with support for reactivity (new methods can be added on demand).</p>
<p>The only major difference is that one cannot use the <code>[]</code> operator.
Users must use the <code>array.get(index)</code> and <code>array.set(index, value)</code> methods instead.</p>
<p>Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveArray</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Optionally accepts initial content</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">array</span><span class="hl-1"> = </span><span class="hl-6">reactiveArray</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">&gt;();</span><br/><br/><span class="hl-8">// Prints undefined since the array is initially empty</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">get</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">));</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">push</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">); </span><span class="hl-8">// effect prints 1</span><br/><br/><span class="hl-8">// later</span><br/><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">set</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">123</span><span class="hl-1">); </span><span class="hl-8">// effect prints 123</span>
</code><button type="button">Copy</button></pre>

<a id="set" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Set<a href="#set" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The <code>ReactiveSet&lt;T&gt;</code> can be used as substitute for the standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set&lt;T&gt;</code></a>.</p>
<p>Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveSet</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Optionally accepts initial content</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">set</span><span class="hl-1"> = </span><span class="hl-6">reactiveSet</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">&gt;();</span><br/><br/><span class="hl-8">// Prints 0 since the set is initially empty</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">set</span><span class="hl-1">.</span><span class="hl-2">size</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">set</span><span class="hl-1">.</span><span class="hl-6">add</span><span class="hl-1">(</span><span class="hl-9">123</span><span class="hl-1">); </span><span class="hl-8">// effect prints 1</span>
</code><button type="button">Copy</button></pre>

<a id="map" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Map<a href="#map" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The <code>ReactiveMap&lt;T&gt;</code> can be used as a substitute for the standard <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map&lt;T&gt;</code></a>.</p>
<p>Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveMap</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Optionally accepts initial content</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">map</span><span class="hl-1"> = </span><span class="hl-6">reactiveMap</span><span class="hl-1">&lt;</span><span class="hl-10">string</span><span class="hl-1">, </span><span class="hl-10">string</span><span class="hl-1">&gt;();</span><br/><br/><span class="hl-8">// Prints undefined since the map is initially empty</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">map</span><span class="hl-1">.</span><span class="hl-6">get</span><span class="hl-1">(</span><span class="hl-3">&quot;foo&quot;</span><span class="hl-1">));</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">map</span><span class="hl-1">.</span><span class="hl-6">set</span><span class="hl-1">(</span><span class="hl-3">&quot;foo&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;bar&quot;</span><span class="hl-1">); </span><span class="hl-8">// effect prints &quot;bar&quot;</span>
</code><button type="button">Copy</button></pre>

<a id="struct" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Struct<a href="#struct" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>With the basic building blocks like <code>reactive</code> and <code>computed</code> you are able to create reactive objects.
For example, you can create a <code>Person</code> class having a first name, a last name and computed property computing the full name, whenever first or last name changes.
Instances of that class are reactive objects.</p>
<p>The reactivity API helps you to create simple reactive objects by providing a function called <code>reactiveStruct</code>.</p>
<p>For example, to create a person with <code>reactiveStruct</code> proceed as follows:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactiveStruct</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// declare a type for the reactive object</span><br/><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-10">Person</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">firstName</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">lastName</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">;</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-8">// define a class like PersonClass</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">PersonClass</span><span class="hl-1"> = </span><span class="hl-6">reactiveStruct</span><span class="hl-1">&lt;</span><span class="hl-10">Person</span><span class="hl-1">&gt;().</span><span class="hl-6">define</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">firstName:</span><span class="hl-1"> {}, </span><span class="hl-8">// default options (reactive and writable)</span><br/><span class="hl-1">    </span><span class="hl-2">lastName:</span><span class="hl-1"> { </span><span class="hl-2">writable:</span><span class="hl-1"> </span><span class="hl-4">false</span><span class="hl-1"> } </span><span class="hl-8">// read-only</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// create a new reactive instance</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">person</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">PersonClass</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">firstName:</span><span class="hl-1"> </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-2">lastName:</span><span class="hl-1"> </span><span class="hl-3">&quot;Doe&quot;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// compute the full name</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">fullName</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-3">`</span><span class="hl-4">${</span><span class="hl-2">person</span><span class="hl-7">.</span><span class="hl-2">firstName</span><span class="hl-4">}</span><span class="hl-3"> </span><span class="hl-4">${</span><span class="hl-2">person</span><span class="hl-7">.</span><span class="hl-2">lastName</span><span class="hl-4">}</span><span class="hl-3">`</span><span class="hl-1">);</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">fullName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// John Doe</span><br/><br/><span class="hl-2">person</span><span class="hl-1">.</span><span class="hl-2">firstName</span><span class="hl-1"> = </span><span class="hl-3">&quot;Jane&quot;</span><span class="hl-1">;</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">fullName</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// Jane Doe</span>
</code><button type="button">Copy</button></pre>

<p>The <code>define</code> function can be used to</p>
<ul>
<li>make properties read-only</li>
<li>declare non-reactive properties</li>
<li>create computed properties</li>
<li>add methods to the reactive object</li>
</ul>
<p>The following example shows declaring an extended <code>Person</code>:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactiveStruct</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-10">Person</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">firstName</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">lastName</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">fullName</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">; </span><span class="hl-8">// will be a computed property</span><br/><span class="hl-1">    </span><span class="hl-6">printName</span><span class="hl-1">(): </span><span class="hl-10">void</span><span class="hl-1">; </span><span class="hl-8">// a method printing the full name</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">PersonClass</span><span class="hl-1"> = </span><span class="hl-6">reactiveStruct</span><span class="hl-1">&lt;</span><span class="hl-10">Person</span><span class="hl-1">&gt;().</span><span class="hl-6">define</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">firstName:</span><span class="hl-1"> {},</span><br/><span class="hl-1">    </span><span class="hl-2">lastName:</span><span class="hl-1"> { </span><span class="hl-2">writable:</span><span class="hl-1"> </span><span class="hl-4">false</span><span class="hl-1"> },</span><br/><span class="hl-1">    </span><span class="hl-2">fullName:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-6">compute</span><span class="hl-1">() {</span><br/><span class="hl-1">            </span><span class="hl-8">// executed whenever first or last name changes</span><br/><span class="hl-1">            </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-3">`</span><span class="hl-4">${</span><span class="hl-4">this</span><span class="hl-7">.</span><span class="hl-2">firstName</span><span class="hl-4">}</span><span class="hl-3"> </span><span class="hl-4">${</span><span class="hl-4">this</span><span class="hl-7">.</span><span class="hl-2">lastName</span><span class="hl-4">}</span><span class="hl-3">`</span><span class="hl-1">;</span><br/><span class="hl-1">        }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-2">printName:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-6">method</span><span class="hl-1">() {</span><br/><span class="hl-1">            </span><span class="hl-8">// always prints the current full name</span><br/><span class="hl-1">            </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">`My name is </span><span class="hl-4">${</span><span class="hl-4">this</span><span class="hl-7">.</span><span class="hl-2">fullName</span><span class="hl-4">}</span><span class="hl-3">`</span><span class="hl-1">);</span><br/><span class="hl-1">        }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// create a new reactive instance</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">person</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">PersonClass</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-2">firstName:</span><span class="hl-1"> </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-2">lastName:</span><span class="hl-1"> </span><span class="hl-3">&quot;Doe&quot;</span><br/><span class="hl-1">});</span><br/><span class="hl-2">person</span><span class="hl-1">.</span><span class="hl-6">printName</span><span class="hl-1">(); </span><span class="hl-8">// My name is John Doe</span><br/><span class="hl-2">person</span><span class="hl-1">.</span><span class="hl-2">firstName</span><span class="hl-1"> = </span><span class="hl-3">&quot;Jane&quot;</span><span class="hl-1">;</span><br/><span class="hl-2">person</span><span class="hl-1">.</span><span class="hl-6">printName</span><span class="hl-1">(); </span><span class="hl-8">// My name is Jane Doe</span>
</code><button type="button">Copy</button></pre>

<p>Reactive structs are designed to help implement very simple classes: you can think of reactive structs as objects having reactive properties, computed properties and methods.
They are not designed to replace every usage of the <code>class</code> keyword.
For example, they do not support base classes or private properties.</p>
<p>If you need an advanced class, we recommend writing it yourself using standard JavaScript / TypeScript means.
You can still (if needed) use a reactive struct internally, or you can use manual signals instead.</p>
<a id="integrating-external-state" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Integrating external state<a href="#integrating-external-state" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>This reactivity system does automatically integrate with other ways to manage state (e.g. event based systems, third party reactivity systems).
However, we do provide facilities to easily integrate &quot;external&quot; state yourself using the <code>external</code> signal.</p>
<p>To use <code>external</code>, you must implement two functionalities:</p>
<ol>
<li>A function to <em>compute</em> the <em>current</em> value of the external state.
This is very similar to the way computed signals work, but it is not automatically reactive.</li>
<li>You must subscribe to changes of the external state (through whatever appropriate means) and <code>.trigger()</code> the external signal.
This tells our reactivity system that the current value is no longer up-to-date.</li>
</ol>
<p>Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">external</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// An abort signal is a value that may be `aborted` through its controller.</span><br/><span class="hl-8">// It provides both the `aborted` property (the current state) and a simple event that fires when that state changes.</span><br/><span class="hl-8">// We use these facilities to provide a reactive boolean that accurately reflects the current state.</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">controller</span><span class="hl-1"> = </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-6">AbortController</span><span class="hl-1">();</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">signal</span><span class="hl-1"> = </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-2">signal</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// boolean signal that tracks the aborted state.</span><br/><span class="hl-8">// calls &#39;trigger()` on the signal when the signal is aborted.</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">isAborted</span><span class="hl-1"> = </span><span class="hl-6">external</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-2">aborted</span><span class="hl-1">);</span><br/><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-6">addEventListener</span><span class="hl-1">(</span><span class="hl-3">&quot;abort&quot;</span><span class="hl-1">, </span><span class="hl-2">isAborted</span><span class="hl-1">.</span><span class="hl-2">trigger</span><span class="hl-1">);</span><br/><span class="hl-8">// later, don&#39;t forget to unregister the event handler:</span><br/><span class="hl-8">// signal.removeEventListener(&quot;abort&quot;, isAborted.trigger);</span><br/><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;is aborted:&quot;</span><span class="hl-1">, </span><span class="hl-2">isAborted</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">setTimeout</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">controller</span><span class="hl-1">.</span><span class="hl-6">abort</span><span class="hl-1">();</span><br/><span class="hl-1">}, </span><span class="hl-9">1000</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Output:</p>
<pre><code class="text">is aborted: false
is aborted: true
</code><button type="button">Copy</button></pre>

<a id="why" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Why?<a href="#why" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>One of the most important responsibilities of an application is to accurately present the current state of the system.
Such an application will have to implement the means to:</p>
<ol>
<li>
<p>Fetch the <em>current</em> state and present it to the user.</p>
</li>
<li>
<p>Subscribe to state changes:</p>
<ul>
<li>On change, goto 1.</li>
</ul>
</li>
</ol>
<p>While step 1 is rather trivial, step 2 turns out to contain lots of complexity in practice, especially if many different sources of state (e.g. objects) are involved.</p>
<p>Many frameworks have found different solutions for keeping the UI synchronized with the application's state (e.g. React, Vue, Flux architecture, store libraries such as Zustand/VueX/Pinia, etc.).
These solutions often come with some trade-offs:</p>
<ul>
<li>They are often tied to an UI framework (e.g. React).</li>
<li>They may impose unusual programming paradigms (e.g. a centralized store instead of a graph of objects) that may be different to integrate with technologies like TypeScript.</li>
<li>They may only support reactivity for <em>some</em> objects.
For example, Vue's reactivity system is based on wrapping objects with proxies; this is incompatible with some legitimate objects - a fact that can be both surprising and difficult to debug.</li>
<li>They may only support reactivity <em>locally</em>.
For example, a store library may support reactivity <em>within</em> a single store, but referring to values from multiple stores may be difficult.</li>
</ul>
<p>This library implements a different set of trade-offs, based on <a href="https://github.com/preactjs/signals">signals</a>:</p>
<ul>
<li>The implementation is not tied to any UI technology.
It can be used with any UI Framework, or none, or multiple UI Frameworks at the same time.</li>
<li>All kinds of values are supported.
Updating the current value in a reactive &quot;box&quot; will notify all interested parties (such as effects, watchers or computed objects).
However, values that have not been prepared for reactivity will not be deeply reactive: when authoring a class, one has to use the reactive primitives or collections provided by this package.</li>
<li>State can be kept in objects and classes (this pairs nicely with TypeScript).
The state rendered by the user interface can be gathered from an arbitrary set of objects.</li>
</ul>
<a id="api" class="tsd-anchor"></a><h2 class="tsd-anchor-link">API<a href="#api" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>See the comments inside the type declarations or the built TypeDoc documentation.</p>
<a id="installation" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Installation<a href="#installation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>With <a href="https://npmjs.org/">npm</a> installed, run</p>
<pre><code class="sh"><span class="hl-6">npm</span><span class="hl-1"> </span><span class="hl-3">install</span><span class="hl-1"> </span><span class="hl-3">@conterra/reactivity-core</span>
</code><button type="button">Copy</button></pre>

<a id="gotchas-and-tips" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Gotchas and tips<a href="#gotchas-and-tips" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><a id="avoid-cycles-in-computed-signals" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Avoid cycles in computed signals<a href="#avoid-cycles-in-computed-signals" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Don't use the value of a computed signal during its own computation.
The error will be obvious in a simple example, but it may also occur by accident when many objects or functions are involved.</p>
<p>Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">computed</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">computedValue</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// Trivial example. This may happen through many layers of indirection in real world code.</span><br/><span class="hl-1">    </span><span class="hl-4">let</span><span class="hl-1"> </span><span class="hl-2">v</span><span class="hl-1"> = </span><span class="hl-2">computedValue</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-2">v</span><span class="hl-1"> * </span><span class="hl-9">2</span><span class="hl-1">;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">computedValue</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// throws &quot;Cycle detected&quot;</span>
</code><button type="button">Copy</button></pre>

<a id="dont-trigger-an-effect-from-within-itself" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Don't trigger an effect from within itself<a href="#dont-trigger-an-effect-from-within-itself" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Updating the value of some signal from within an effect is fine in general.
However, you should take care not to produce a cycle.</p>
<p>Example: this is okay (but could be replaced by a computed signal).</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v2</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// Updates v2 whenever v1 changes</span><br/><span class="hl-1">    </span><span class="hl-2">v2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">v1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> * </span><span class="hl-9">2</span><span class="hl-1">;</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>Example: this is <em>not</em> okay.</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// same as `v1.value = v1.value + 1`</span><br/><span class="hl-1">    </span><span class="hl-2">v1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">; </span><span class="hl-8">// throws!</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>This is the shortest possible example of a cycle within an effect.
When the effect executed, it <em>reads</em> from <code>v1</code> (thus requiring that the effect re-executes whenever <code>v1</code> changes)
and then it <em>writes</em> to v1, thus changing it.
This effect would re-trigger itself endlessly - luckily the underlying signals library throws an exception when this case is detected.</p>
<a id="workaround" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Workaround<a href="#workaround" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Sometimes you <em>really</em> have to read something and don't want to become a reactive dependency.
In that case, you can wrap the code block with <code>untracked()</code>.
Example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">untracked</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-8">// Code inside untracked() will not be come a dependency of the effect.</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">value</span><span class="hl-1"> = </span><span class="hl-6">untracked</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">v1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-2">v1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-2">value</span><span class="hl-1"> + </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>The example above will not throw an error anymore because the <em>read</em> to <code>v1</code> has been wrapped with <code>untracked()</code>.</p>
<blockquote>
<p>NOTE: In very simple situations you can also use the <code>.peek()</code> method of a signal, which is essentially a tiny <code>untracked</code> block that only reads from that signal. The code above could be changed to <code>const value = v1.peek()</code>.</p>
</blockquote>
<a id="batching-multiple-updates" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Batching multiple updates<a href="#batching-multiple-updates" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Every update to a signal will usually trigger all watchers.
This is not really a problem when using the default <code>watch()</code> or <code>effect()</code>, since multiple changes that follow <em>immediately</em> after each other are grouped into a single notification, with a minimal delay.</p>
<p>However, when using <code>syncEffect</code> or <code>syncWatch</code>, you will be triggered many times:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">syncEffect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">count</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">syncEffect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-8">// Effect has executed 5 times</span>
</code><button type="button">Copy</button></pre>

<p>You can avoid this by grouping many updates into a single <em>batch</em>.
Effects or watchers will not get notified until the batch is complete:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">syncEffect</span><span class="hl-1">, </span><span class="hl-2">batch</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">count</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">syncEffect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">batch</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">count</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">});</span><br/><span class="hl-8">// Effect has executed only twice: one initial call and once after batch() as completed.</span>
</code><button type="button">Copy</button></pre>

<p>It is usually a good idea to surround a complex update operation with <code>batch()</code>.</p>
<a id="sync-vs-async-effect--watch" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Sync vs async effect / watch<a href="#sync-vs-async-effect--watch" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>By default, the re-executions of <code>effect</code> and the callback executions of <code>watch</code> do not happen <em>immediately</em> when a signal is changed.
Instead, the new executions are dispatched to occur in the next <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">event loop iteration (&quot;macro task&quot;)</a>.
This means that they are delayed very slightly (similar to <code>setTimeout(..., 0)</code>) in order to group multiple synchronous changes into a single execution (see <a href="#batching-multiple-updates">Batching</a>).</p>
<p>Consider the following example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">watch</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;effect:&quot;</span><span class="hl-1">, </span><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">watch</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> [</span><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">],</span><br/><span class="hl-1">    ([</span><span class="hl-2">value</span><span class="hl-1">]) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;watch:&quot;</span><span class="hl-1">, </span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">2</span><span class="hl-1">;</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;after assignment&quot;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>This will print:</p>
<pre><code class="text">effect: 1           # the initial effect execution always happens synchronously
after assignment    # watch and effect did NOT execute yet
effect: 2           # now effect and watch will execute
watch: 2
</code><button type="button">Copy</button></pre>

<p>If you need more control over your callbacks, you can use <code>syncEffect</code> and <code>syncWatch</code> instead:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">syncWatch</span><span class="hl-1">, </span><span class="hl-2">syncEffect</span><span class="hl-1">, </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-6">syncEffect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;effect:&quot;</span><span class="hl-1">, </span><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">syncWatch</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> [</span><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">],</span><br/><span class="hl-1">    ([</span><span class="hl-2">value</span><span class="hl-1">]) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;watch:&quot;</span><span class="hl-1">, </span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-2">s</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">2</span><span class="hl-1">; </span><span class="hl-8">// this line also executes the effect and the watch callback!</span><br/><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;after assignment&quot;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>This will print:</p>
<pre><code class="text">effect: 1
effect: 2
watch: 2
after assignment
</code><button type="button">Copy</button></pre>

<a id="writing-nonreactive-code" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Writing nonreactive code<a href="#writing-nonreactive-code" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Sometimes you want to read the <em>current</em> value of a signal without being triggered when that signal changes.
You can do that by opting out of the automatic dependency tracking using the <code>untracked</code> function, for example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">untracked</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s2</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-2">s1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">; </span><span class="hl-8">// tracked read</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v2</span><span class="hl-1"> = </span><span class="hl-6">untracked</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">s2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">); </span><span class="hl-8">// untracked read</span><br/><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;effect&quot;</span><span class="hl-1">, </span><span class="hl-2">v1</span><span class="hl-1">, </span><span class="hl-2">v2</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">s2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">1</span><span class="hl-1">; </span><span class="hl-8">// does not cause the effect to trigger again</span><br/><span class="hl-2">s1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-9">1</span><span class="hl-1">; </span><span class="hl-8">// _does_ cause the effect to trigger again</span>
</code><button type="button">Copy</button></pre>

<p><code>untracked()</code> works everywhere dependencies are tracked:</p>
<ul>
<li>inside <code>computed()</code></li>
<li>in effect callbacks</li>
<li>in the <code>selector</code> argument of <code>watch()</code></li>
</ul>
<a id="effects-triggering-often-when-working-with-collections" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Effects triggering often when working with collections<a href="#effects-triggering-often-when-working-with-collections" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The current implementation of collection types (<code>Array</code>, <code>Map</code>, <code>Set</code>) only supports fine grained reactivity for <em>existing</em> values.
When the set of values is changed (e.g. by calling <code>.push()</code> on an array or <code>.set</code> with a new key on a <code>Map</code>), only a coarse &quot;change event&quot; will be emitted.</p>
<p>Consider the following example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveArray</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">array</span><span class="hl-1"> = </span><span class="hl-6">reactiveArray</span><span class="hl-1">([</span><span class="hl-9">1</span><span class="hl-1">]);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;first array item&quot;</span><span class="hl-1">, </span><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">get</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">));</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">push</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The snippet above will print the first array item <em>twice</em>, even though that item is never modified.
The current implementation is a compromise between memory efficiency, code complexity and usability that results in this quirk.</p>
<p>To work around the issue, simply use a <code>watch()</code> or wrap the array access into a <code>computed()</code> signal.
Both ways will ensure that the effect or callback is only triggered when the value <em>actually</em> changed:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">computed</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactiveArray</span><span class="hl-1">, </span><span class="hl-2">watch</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">array</span><span class="hl-1"> = </span><span class="hl-6">reactiveArray</span><span class="hl-1">([</span><span class="hl-9">1</span><span class="hl-1">]);</span><br/><br/><span class="hl-8">// This works because computed() caches its value and only propagates change</span><br/><span class="hl-8">// when the value is actually updated.</span><br/><span class="hl-8">// Essentially, the computed&#39;s callback will still re-execute but no one else will be notified.</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">firstItem</span><span class="hl-1"> = </span><span class="hl-6">computed</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">get</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">));</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;first array item (effect)&quot;</span><span class="hl-1">, </span><span class="hl-2">firstItem</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-8">// This works because the callback is only invoked when the selector returns different values.</span><br/><span class="hl-8">// Essentially, the selector is executed multiple times but watch() will not invoke the callback.</span><br/><span class="hl-8">// (Behind the scenes, watch() is based on `computed` as well).</span><br/><span class="hl-6">watch</span><span class="hl-1">(</span><br/><span class="hl-1">    () </span><span class="hl-4">=&gt;</span><span class="hl-1"> [</span><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">get</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">)],</span><br/><span class="hl-1">    ([</span><span class="hl-2">item</span><span class="hl-1">]) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;first array item (watch)&quot;</span><span class="hl-1">, </span><span class="hl-2">item</span><span class="hl-1">);</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-8">// Triggers neither the effect nor the watch callback.</span><br/><span class="hl-2">array</span><span class="hl-1">.</span><span class="hl-6">push</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="working-with-promises" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Working with promises<a href="#working-with-promises" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>It is a completely legitimate use case to manage asynchronous operations (involving promises) from reactive code, such as <code>effect()</code> or <code>watch()</code>.</p>
<p>For example, the following code will re-trigger another &quot;long running operation&quot; whenever <code>input</code> changes:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">input</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;foo&quot;</span><span class="hl-1">);</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">currentInput</span><span class="hl-1"> = </span><span class="hl-2">input</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-6">longRunningOperation</span><span class="hl-1">(</span><span class="hl-2">currentInput</span><span class="hl-1">).</span><span class="hl-6">catch</span><span class="hl-1">((</span><span class="hl-2">e</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">error</span><span class="hl-1">(</span><span class="hl-3">&quot;Something went wrong&quot;</span><span class="hl-1">, </span><span class="hl-2">e</span><span class="hl-1">);</span><br/><span class="hl-1">    });</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-2">input</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;bar&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">async</span><span class="hl-1"> </span><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">longRunningOperation</span><span class="hl-1">(</span><span class="hl-2">param</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-8">// ...</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;long running:&quot;</span><span class="hl-1">, </span><span class="hl-2">param</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>You can also use signals to track the status of an asynchronous operation:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">effect</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">type</span><span class="hl-1"> </span><span class="hl-10">JobState</span><span class="hl-1"> =</span><br/><span class="hl-1">    | { </span><span class="hl-2">state</span><span class="hl-1">: </span><span class="hl-3">&quot;pending&quot;</span><span class="hl-1"> }</span><br/><span class="hl-1">    | { </span><span class="hl-2">state</span><span class="hl-1">: </span><span class="hl-3">&quot;done&quot;</span><span class="hl-1">; </span><span class="hl-2">result</span><span class="hl-1">: </span><span class="hl-10">unknown</span><span class="hl-1"> }</span><br/><span class="hl-1">    | { </span><span class="hl-2">state</span><span class="hl-1">: </span><span class="hl-3">&quot;error&quot;</span><span class="hl-1">; </span><span class="hl-2">error</span><span class="hl-1">: </span><span class="hl-10">unknown</span><span class="hl-1"> };</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">jobState</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">&lt;</span><span class="hl-10">JobState</span><span class="hl-1">&gt;({ </span><span class="hl-2">state:</span><span class="hl-1"> </span><span class="hl-3">&quot;pending&quot;</span><span class="hl-1"> });</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">jobState</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">performJob</span><span class="hl-1">()</span><br/><span class="hl-1">    .</span><span class="hl-6">then</span><span class="hl-1">((</span><span class="hl-2">result</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">jobState</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">state:</span><span class="hl-1"> </span><span class="hl-3">&quot;done&quot;</span><span class="hl-1">, </span><span class="hl-2">result</span><span class="hl-1"> };</span><br/><span class="hl-1">    })</span><br/><span class="hl-1">    .</span><span class="hl-6">catch</span><span class="hl-1">((</span><span class="hl-2">error</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">jobState</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = { </span><span class="hl-2">state:</span><span class="hl-1"> </span><span class="hl-3">&quot;error&quot;</span><span class="hl-1">, </span><span class="hl-2">error</span><span class="hl-1"> };</span><br/><span class="hl-1">    });</span><br/><br/><span class="hl-4">async</span><span class="hl-1"> </span><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">performJob</span><span class="hl-1">() {</span><br/><span class="hl-1">    </span><span class="hl-8">// ...</span><br/><span class="hl-1">    </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-9">42</span><span class="hl-1">;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p><strong>However, one should not use asynchronous code (i.e. the keywords <code>async</code> and <code>await</code>) <em>directly</em> in an effect/watch/computed.</strong>
The following snippet is bad style and can lead to surprising behavior:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">effect</span><span class="hl-1">, </span><span class="hl-2">reactive</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s1</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;a&quot;</span><span class="hl-1">);</span><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">s2</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-3">&quot;b&quot;</span><span class="hl-1">);</span><br/><br/><span class="hl-8">/// XXX BAD style</span><br/><span class="hl-8">/// Note the `async` keyword</span><br/><span class="hl-6">effect</span><span class="hl-1">(</span><span class="hl-4">async</span><span class="hl-1"> () </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-2">s1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">result</span><span class="hl-1"> = </span><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-6">functionThatReturnsAPromise</span><span class="hl-1">(</span><span class="hl-2">v1</span><span class="hl-1">); </span><span class="hl-8">// (1)</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v2</span><span class="hl-1"> = </span><span class="hl-2">s2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">v2</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">setTimeout</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">s2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> = </span><span class="hl-3">&quot;c&quot;</span><span class="hl-1">; </span><span class="hl-8">// (2)</span><br/><span class="hl-1">}, </span><span class="hl-9">1000</span><span class="hl-1">);</span><br/><br/><span class="hl-4">async</span><span class="hl-1"> </span><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">functionThatReturnsAPromise</span><span class="hl-1">(</span><span class="hl-2">v1</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-8">// ...</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>The effect will be executed once (initially) but it will <em>not</em> be triggered by the update in (2).</p>
<p>This is because the original read (<code>s2.value</code>) was not observed by the effect, which will become more obvious
when we write the same effect in a different style:</p>
<pre><code class="ts"><span class="hl-8">// does pretty much the same as the previous effect</span><br/><span class="hl-6">effect</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v1</span><span class="hl-1"> = </span><span class="hl-2">s1</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-6">functionThatReturnsAPromise</span><span class="hl-1">(</span><span class="hl-2">v1</span><span class="hl-1">).</span><span class="hl-6">then</span><span class="hl-1">((</span><span class="hl-2">result</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">v2</span><span class="hl-1"> = </span><span class="hl-2">s2</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">;</span><br/><span class="hl-1">        </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-2">v2</span><span class="hl-1">);</span><br/><span class="hl-1">    });</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>While the read to <code>s1.value</code> happens <em>directly</em> inside the effect, the access to <code>v2.value</code> happens later, possibly much later.
No matter how long it takes, the callback executed by the effect will already have completed by then: all APIs in this package can only track reactive dependencies in <em>synchronous</em> code.</p>
<p>If you must use an asynchronous function directly in a reactive context, keep in mind that only the code until the first <code>await</code> statement will actually become reactive.
However, because this is confusing and error prone, it is best to avoid it altogether.</p>
<a id="self-destructing-effects-or-watches" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Self-destructing effects or watches<a href="#self-destructing-effects-or-watches" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The different variants of <code>watch</code> and <code>effect</code> support a <code>ctx</code> parameter, which can be used to cancel the object from within its own callback.
This can be useful to wait for a certain condition, while ensuring that the callback does not trigger again after the condition is met.</p>
<p>For example:</p>
<pre><code class="ts"><span class="hl-0">import</span><span class="hl-1"> { </span><span class="hl-2">reactive</span><span class="hl-1">, </span><span class="hl-2">ReadonlyReactive</span><span class="hl-1">, </span><span class="hl-2">watchValue</span><span class="hl-1"> } </span><span class="hl-0">from</span><span class="hl-1"> </span><span class="hl-3">&quot;@conterra/reactivity-core&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">// Waits for the signal to be at least 2.</span><br/><span class="hl-4">function</span><span class="hl-1"> </span><span class="hl-6">waitForTwo</span><span class="hl-1">(</span><span class="hl-2">signal</span><span class="hl-1">: </span><span class="hl-10">ReadonlyReactive</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">&gt;): </span><span class="hl-10">Promise</span><span class="hl-1">&lt;</span><span class="hl-10">void</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">    </span><span class="hl-0">return</span><span class="hl-1"> </span><span class="hl-4">new</span><span class="hl-1"> </span><span class="hl-10">Promise</span><span class="hl-1">((</span><span class="hl-2">resolve</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">handle</span><span class="hl-1"> = </span><span class="hl-6">watchValue</span><span class="hl-1">(</span><br/><span class="hl-1">            () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1">,</span><br/><span class="hl-1">            (</span><span class="hl-2">value</span><span class="hl-1">, </span><span class="hl-2">_oldValue</span><span class="hl-1">, </span><span class="hl-2">ctx</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">                </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;intermediate value&quot;</span><span class="hl-1">, </span><span class="hl-2">value</span><span class="hl-1">);</span><br/><br/><span class="hl-1">                </span><span class="hl-8">// resolve the promise when the condition is met</span><br/><span class="hl-1">                </span><span class="hl-0">if</span><span class="hl-1"> (</span><span class="hl-2">value</span><span class="hl-1"> &gt;= </span><span class="hl-9">2</span><span class="hl-1">) {</span><br/><span class="hl-1">                    </span><span class="hl-8">// may result in error: handle.destroy();</span><br/><span class="hl-1">                    </span><span class="hl-8">// this always works:</span><br/><span class="hl-1">                    </span><span class="hl-2">ctx</span><span class="hl-1">.</span><span class="hl-6">destroy</span><span class="hl-1">();</span><br/><span class="hl-1">                    </span><span class="hl-6">resolve</span><span class="hl-1">();</span><br/><span class="hl-1">                }</span><br/><span class="hl-1">            },</span><br/><span class="hl-1">            {</span><br/><span class="hl-1">                </span><span class="hl-8">// run immediately to check the initial value as well</span><br/><span class="hl-1">                </span><span class="hl-2">immediate:</span><span class="hl-1"> </span><span class="hl-4">true</span><br/><span class="hl-1">            }</span><br/><span class="hl-1">        );</span><br/><span class="hl-1">    });</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-4">const</span><span class="hl-1"> </span><span class="hl-5">signal</span><span class="hl-1"> = </span><span class="hl-6">reactive</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-6">waitForTwo</span><span class="hl-1">(</span><span class="hl-2">signal</span><span class="hl-1">).</span><span class="hl-6">then</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-3">&quot;done&quot;</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">setTimeout</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-6">setTimeout</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">        </span><span class="hl-6">setTimeout</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">            </span><span class="hl-8">// 3 is not printed by the watch callback since it has been destroyed</span><br/><span class="hl-1">            </span><span class="hl-2">signal</span><span class="hl-1">.</span><span class="hl-2">value</span><span class="hl-1"> += </span><span class="hl-9">1</span><span class="hl-1">;</span><br/><span class="hl-1">        }, </span><span class="hl-9">250</span><span class="hl-1">);</span><br/><span class="hl-1">    }, </span><span class="hl-9">250</span><span class="hl-1">);</span><br/><span class="hl-1">}, </span><span class="hl-9">250</span><span class="hl-1">);</span><br/><br/><span class="hl-8">// Prints:</span><br/><span class="hl-8">// intermediate value 0</span><br/><span class="hl-8">// intermediate value 1</span><br/><span class="hl-8">// intermediate value 2</span><br/><span class="hl-8">// done</span>
</code><button type="button">Copy</button></pre>

<p>In the example above, the watch callback resolves the promise (and destroys itself) when the signal reaches 2.
The watch callback not only checks <em>new</em> values, but also the initial value due to <code>immediate: true</code>.
A subtle bug could be introduced by calling <code>handle.destroy()</code> here, since it is not available during the initial execution of the watch callback (the callback runs <em>inside</em> <code>watchValue</code> which has not returned yet).
<code>ctx.destroy()</code> on the other hand can always be used.</p>
<a id="license" class="tsd-anchor"></a><h2 class="tsd-anchor-link">License<a href="#license" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Apache-2.0 (see <code>LICENSE</code> file)</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#conterrareactivity-core"><span>@conterra/reactivity-<wbr/>core</span></a><ul><li><a href="#quick-example"><span>Quick <wbr/>Example</span></a></li><li><a href="#usage"><span>Usage</span></a></li><li><ul><li><a href="#basics"><span>Basics</span></a></li><li><a href="#using-signals-for-reactive-object-properties"><span>Using signals for reactive object properties</span></a></li><li><a href="#effect-vs-watch"><span>Effect vs. <wbr/>Watch</span></a></li><li><a href="#accessing-previous-values"><span>Accessing previous values</span></a></li><li><a href="#returning-cleanup-functions"><span>Returning cleanup functions</span></a></li><li><ul><li><a href="#cheat-sheet-variants-of-effect-and-watch"><span>Cheat sheet: variants of effect and watch</span></a></li></ul></li><li><a href="#complex-values"><span>Complex values</span></a></li><li><a href="#working-with-collections"><span>Working with collections</span></a></li><li><ul><li><a href="#using-immutable-values"><span>Using immutable values</span></a></li><li><a href="#using-reactive-collection-classes"><span>Using reactive collection classes</span></a></li></ul></li><li><a href="#cleanup"><span>Cleanup</span></a></li><li><a href="#reactive-collections"><span>Reactive collections</span></a></li><li><ul><li><a href="#array"><span>Array</span></a></li><li><a href="#set"><span>Set</span></a></li><li><a href="#map"><span>Map</span></a></li><li><a href="#struct"><span>Struct</span></a></li><li><a href="#integrating-external-state"><span>Integrating external state</span></a></li></ul></li></ul></li><li><a href="#why"><span>Why?</span></a></li><li><a href="#api"><span>API</span></a></li><li><a href="#installation"><span>Installation</span></a></li><li><a href="#gotchas-and-tips"><span>Gotchas and tips</span></a></li><li><ul><li><a href="#avoid-cycles-in-computed-signals"><span>Avoid cycles in computed signals</span></a></li><li><a href="#dont-trigger-an-effect-from-within-itself"><span>Don&#39;t trigger an effect from within itself</span></a></li><li><ul><li><a href="#workaround"><span>Workaround</span></a></li></ul></li><li><a href="#batching-multiple-updates"><span>Batching multiple updates</span></a></li><li><a href="#sync-vs-async-effect--watch"><span>Sync vs async effect / watch</span></a></li><li><a href="#writing-nonreactive-code"><span>Writing nonreactive code</span></a></li><li><a href="#effects-triggering-often-when-working-with-collections"><span>Effects triggering often when working with collections</span></a></li><li><a href="#working-with-promises"><span>Working with promises</span></a></li><li><a href="#self-destructing-effects-or-watches"><span>Self-<wbr/>destructing effects or watches</span></a></li></ul></li><li><a href="#license"><span>License</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="modules.html">@conterra/reactivity-core - v0.4.4</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
